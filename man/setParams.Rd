% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MizerParams-class.R
\name{setParams}
\alias{setParams}
\title{Set or change any model parameters}
\usage{
setParams(params, interaction = NULL, pred_kernel = NULL,
  search_vol = NULL, q = params@q, f0 = params@f0,
  intake_max = NULL, n = params@n, metab = NULL, p = params@p,
  mu_b = NULL, z0pre = 0.6, z0exp = n - 1, maturity = NULL,
  repro_prop = NULL, srr = params@srr, kappa = params@kappa,
  lambda = params@lambda, r_pp = 10, w_pp_cutoff = 10,
  plankton_dynamics = NULL,
  resource_dynamics = params@resource_dynamics,
  resource_params = params@resource_params, rho = NULL)
}
\arguments{
\item{params}{A \linkS4class{MizerParams} object}

\item{interaction}{Interaction matrix of the species (predator by prey).
Entries should be numbers between 0 and 1. See "Setting interactions"
section below.}

\item{pred_kernel}{Optional. An array (species x predator size x prey size)
that holds the predation coefficient of each predator at size on each prey
size. If not supplied, a default is set as described in section "Setting
predation kernel".}

\item{search_vol}{Optional. An array (species x size) holding the search volume
for each species at size. If not supplied, a default is set as described in
the section "Setting search volume".}

\item{q}{Exponent of the allometric search volume. Not needed if a
\code{search_vol} array is specified.}

\item{f0}{Average feeding level. Used to calculated \code{h} and \code{gamma}
if those are not columns in the species data frame. Also requires
\code{k_vb} (the von Bertalanffy K parameter) to be a column in the species
data frame.}

\item{intake_max}{Optional. An array (species x size) holding the maximum
intake rate for each species at size. If not supplied, a default is set as
described in the section "Setting maximum intake rate".}

\item{n}{Scaling exponent of the intake rate.}

\item{metab}{Optional. An array (species x size) holding the metabolic rate
for each species at size. If not supplied, a default is set as described in
the section "Setting metabolic rate".}

\item{p}{Scaling exponent of the standard metabolic rate.}

\item{mu_b}{Optional. An array (species x size) holding the background
mortality rate.}

\item{z0pre}{If \code{z0}, the mortality from other sources, is not a column
in the species data frame, it is calculated as z0pre * w_inf ^ z0exp.
Default value is 0.6.}

\item{z0exp}{If \code{z0}, the mortality from other sources, is not a column
in the species data frame, it is calculated as \code{z0pre * w_inf ^ z0exp}.
Default value is \code{n-1}.}

\item{maturity}{Optional. An array (species x size) that holds the proportion
of individuals of each species at size that are mature. If not supplied, a
default is set as described in the section "Setting reproduction".}

\item{repro_prop}{Optional. An array (species x size) that holds the
proportion of consumed energy that a mature individual allocates to
reproduction for each species at size. If not supplied, a default is set as
described in the section "Setting reproduction".}

\item{srr}{Optional. The stock recruitment function.}

\item{kappa}{Carrying capacity of the plankton spectrum.}

\item{lambda}{Exponent of the plankton spectrum.}

\item{r_pp}{Growth rate of the primary productivity. Default is 10 g/year.}

\item{w_pp_cutoff}{The upper cut off size of the plankton spectrum. 
Default is 10 g.}

\item{plankton_dynamics}{Function that determines plankton dynamics by
calculating the plankton spectrum at the next time step from the current
state.}

\item{resource_dynamics}{A named list of functions that determine the
dynamics of the unstructured resources by calculating their biomasses at
the next time step from the current state. An empty list if the model
does not have unstructured resources.}

\item{resource_params}{A named list of parameters needed by the
\code{resource_dynamics} functions. An empty list if no parameters are
needed.}

\item{rho}{Optional. An array (species x resource x size)
holding the rate at which a consumer of a particular size feeds on each
resource. Described in the section "Setting resource encounter rate".}
}
\value{
A \linkS4class{MizerParams} object
}
\description{
This is a convenient wrapper function calling each of the following
functions
\itemize{
\item \code{\link{setPredKernel}}
\item \code{\link{setSearchVolume}}
\item \code{\link{setInteraction}}
\item \code{\link{setIntakeMax}}
\item \code{\link{setMetab}}
\item \code{\link{setBMort}}
\item \code{\link{setReproduction}}
\item \code{\link{setFishing}}
\item \code{\link{setPlankton}}
\item \code{\link{setResourceDynamics}}
\item \code{\link{setResourceEncounter}}
}
See the Details section below for a discussion of how to use this function.
}
\details{
Usually, if you are happy with the way mizer calculates its model functions
from the species parameters and only want to change the values of some
species parameters, you would make those changes in the \code{species_params} data
frame contained in the \code{params} object and then call the \code{setParams()}
function to effect the change. Note that just changing the species parameters
by themselves is not changing the model until you call \code{setParams()} or the
appropriate one of its sub-functions. Here is an example which assumes that
you have have a MizerParams object \code{params} in which you just want to change
one parameter of the third species:\preformatted{params@species_params$gamma[3] <- 1000
params <- setParams(params)
}

Because of the way the R language works, \code{setParams} does not make the
changes to the \code{params} object that you pass to it but instead returns a new
params object. So to affect the change you call the function in the form
\code{params <- setParams(params, ...)}.

If you are not happy with the assumptions that mizer makes by default about
the shape of the model functions, for example if you want to change one of
the allometric scaling assumptions, you can do this by providing your
choice as an array in the appropriate argument to \code{setParams()}. The
sections below discuss all the model functions that you can change this way.

This function will use the species parameters in the \code{params} object to reset
the values of all the model functions that you do not specify explicitly when
calling this function. If you have changed any of the model functions in the
\code{params} object previously and now want to make changes to a different slot,
you will want to call the appropriate change function individually. So in the
above example you would have used \code{params <- setSearchVolume(params)}
instead of \code{params <- setParams(params)}.
}
\section{Units in mizer}{

Mizer uses grams to measure weight, centimetres to measure lengths, and
years to measure time.

Mizer is agnostic about whether abundances are given as
\enumerate{
\item numbers per area,
\item numbers per volume or
\item total numbers for the entire study area.
}

You should make the choice most convenient for your application and then
stick with it. If you make choice 1 or 2 you will also have to choose a unit
for area or volume. Your choice will then determine the units for some of
the parameters. This will be mentioned when the parameters are discussed in
the sections below.

You choice will also affect the units of the quantities you may want to
calculate with the model. For example, the yield will be in grams/year/m^2 in
case 1 if you choose m^2 as your measure of area, in grams/year/m^3 in case 2
if you choose m^3 as your unit of volume, or simply grams/year in case 3. The
same comment applies for other measures, like total biomass, which will be
grams/area in case 1, grams/volume in case 2 or simply grams in case 3. When
mizer puts units on axes, for example in \code{plotBiomass}, it will simply
put grams, as appropriate for case 3.

You can convert between these choices. For example, if you use case 1, you
need to multiply with the area of the ecosystem to get the total quantity.
If you work with case 2, you need to multiply by both area and the thickness
of the productive layer. In that respect, case 2 is a bit cumbersome.
}

\section{Setting interactions}{


The species interaction matrix \eqn{\theta_{ij}}, is used when calculating the
food encounter rate in \code{\link{getEncounter}} and the predation mortality rate in
\code{\link{getPredMort}}. Its entries are dimensionless numbers between
0 and 1 that characterise the strength at which predator species \eqn{i}
predates on prey species \eqn{j}. 

This function checks that the supplied interaction
matrix is valid and then stores it in the \code{interaction} slot of the
params object before returning that object.

The order of the columns and rows of the \code{interaction} argument should be the 
same as the order in the species params dataframe in the \code{params} object.
If you supply a named array then the function will check the order and warn 
if it is different.

The interaction of the species with the plankton are set via a column
\code{interaction_p} in the \code{species_params} data frame. Again the entries
have to be numbers between 0 and 1. By default this column is set to all
1s.
}

\section{Setting predation kernel}{

\strong{Kernel dependent on predator to prey size ratio}

If the \code{pred_kernel} argument is not supplied, then this function sets a
predation kernel that depends only on the ratio of predator mass to prey
mass, not on the two masses independently. The shape of that kernel is then
determined by the \code{pred_kernel_type} column in species_params.

The default pred_kernel_type is "lognormal". This will call the function
\code{\link{lognormal_pred_kernel}} to calculate the predation kernel.
An alternative pred_kernel type is "box", implemented by the functions
\code{\link{box_pred_kernel}}. These functions require certain species
parameters in the species_params data frame. For the lognormal kernel these
are \code{beta} and \code{sigma}, for the box kernel they are
\code{ppmr_min} and \code{ppmr_max}. They are explained in the help pages
for the kernel functions. No defaults are set for these parameters. If they
are missing from the species_params data frame then mizer will issue an
error message.

You can use any other string as the type. If for example you choose "my" then
you need to define a function \code{my_pred_kernel} that you can model on the
existing functions like \code{\link{lognormal_pred_kernel}}.

When using a kernel that depends on the predator/prey size ratio only, mizer
does not need to store the entire three dimensional array in the MizerParams
object. Such an array can be very big when there is a large number of size
bins. Instead, mizer only needs to store two two-dimensional arrays that hold
Fourier transforms of the feeding kernel function that allow the encounter
rate and the predation rate to be calculated very efficiently. However, if
you need the full three-dimensional array you can calculate it with the
\code{\link{getPredKernel}} function.

\strong{Kernel dependent on both predator and prey size}

If you want to work with a feeding kernel that depends on predator mass and
prey mass independently, you can specify the full feeding kernel as a
three-dimensional array (predator species x predator size x prey size).
The dimensions are thus (no_sp, no_w, no_w_full). 

You should use this option only if a kernel dependent only on the
predator/prey mass ratio is not appropriate. Using a kernel dependent on
predator/prey mass ratio only allows mizer to use fast Fourier transform
methods to significantly reduce the running time of simulations.

The order of the predator species in \code{pred_kernel} should be the same
as the order in the species params dataframe in the `params` object. If you
supply a named array then the function will check the order and warn if it is
different.
}

\section{Setting search volume}{

The search volume \eqn{\gamma_i(w)} of an individual of species \eqn{i}
and weight \eqn{w} multiplies the predation kernel when
calculating the encounter rate in \code{\link{getEncounter}} and the 
predation rate in \code{\link{getPredRate}}.

The name "search volume" is a bit misleading, because \eqn{\gamma_i(w)} does
not have units of volume. It is simply a parameter that determines the rate
of predation. Its units depend on your choice, see section "Units in mizer".
If you have chose to work with total abundances, then it is a rate with units
1/year. If you have chosen to work with abundances per m^2 then it has units
of m^2/year. If you have chosen to work with abundances per m^3 then it has
units of m^3/year.

If the \code{search_vol} argument is not supplied, then the search volume is set to
\deqn{\gamma_i(w) = \gamma_i w^q.} The values of \eqn{\gamma_i} are taken from
the \code{gamma} column in the species parameter dataframe. If the \code{gamma}
column is not supplied in the species parameter dataframe, a default is
calculated by the \code{\link{get_gamma_default}} function. Note that only
for predators of size \eqn{w = 1} gram is the value of the species parameter
\eqn{\gamma_i} the same as the value of the search volume \eqn{\gamma_i(w)}.
}

\section{Setting maximum intake rate}{

The maximum intake rate \eqn{h_i(w)} of an individual of species \eqn{i} and
weight \eqn{w} determines the feeding level, calculated with
\code{\link{getFeedingLevel}}. It is measured in grams/year.

If the \code{intake_max} argument is not supplied, then the maximum intake
rate is set to \deqn{h_i(w) = h_i w^n.} 
The values of \eqn{h_i} (the maximum intake rate of an individual of size
1 gram) are taken from the \code{h} column in the
species parameter dataframe. If the \code{h} column is not supplied in the
species parameter dataframe, it is calculated by the 
\code{\link{get_h_default}} function, using \code{f0} and the \code{k_vb}
column, if they are supplied.

If \eqn{h_i} is set to \code{Inf}, fish will consume all encountered food.
}

\section{Setting metabolic rate}{

The metabolic rate is subtracted from the energy income rate to calculate
the rate at which energy is available for growth and reproduction, see
\code{\link{getEReproAndGrowth}}. It is measured in grams/year.

If the \code{metab} argument is not supplied, then the metabolic
rate \eqn{k_i(w)} for an individual of species \eqn{i} and size \eqn{w}
is set to \deqn{k_i(w) = ks_i\, w^p + k_i\, w,}{k_i(w) = ks_i w^p + k_i w}
where \eqn{ks_i w^p} represents the rate of standard metabolism and 
\eqn{k_i w} is the rate at which energy is expended on activity and movement.
The values of \eqn{ks_i} and \eqn{k_i} are taken from the \code{ks} and
\code{k} columns in the
species parameter dataframe. If these parameters are not supplied, the
defaults are \eqn{ks_i = 0.2 h_i} and \eqn{k_i = 0}, where \eqn{h_i} is the
coefficient of the maximum intake rate and is taken from the species
parameter data frame in \code{params}.
}

\section{Setting background mortality rate}{

The background mortality is all the mortality that is not due to either
predation or fishing. It is a rate with units 1/year.

The \code{mu_b} argument allows you to specify a background mortality rate
that depends on species and body size. You can see an example of this in
the Examples section of the help page for \code{\link{setBMort}}.

If the \code{mu_b} argument is not supplied, then the background mortality
is assumed to depend only on the asymptotic size of the species, not on the
size of the individual: \eqn{\mu_{b.i}(w) = z_{0.i}}. The value of the
constant \eqn{z_0} for each species is taken from the \code{z0} column of the
species_params data frame, if that column exists. Otherwise it is calculated
as \deqn{z_{0.i} = {\tt z0pre}_i\, w_{inf}^{\tt z0exp}.}{z_{0.i} = z0pre_i w_{inf}^{z0exp}.}
}

\section{Setting reproduction}{

For each species and at each size, the proportion of the available energy 
that is invested into reproduction is the product of two factors: the
proportion \code{maturity} of individuals that are mature and the proportion
\code{repro_prop} of the energy available to a mature individual that is 
invested into reproduction.

If the \code{maturity} argument is not supplied, then it is set to a sigmoidal 
maturity ogive that changes from 0 to 1 at around the maturity size:
\deqn{{\tt maturity}(w) = \left[1+\left(\frac{w}{w_{mat}}\right)^{-U}\right]^{-1}.}{
  maturity(w) = [1+(w/w_mat)^(-U)]^(-1)}
(To avoid clutter, we are not showing the species index in the equations.)
The maturity weights are taken from the \code{w_mat} column of the 
species_params data frame. Any missing maturity weights are set to 1/4 of the
asymptotic weight in the \code{w_inf} column.
The exponent \eqn{U} determines the steepness of the maturity ogive. By
default it is chosen as \eqn{U = 10}, however this can be overridden by
including a column \code{w_mat25} in the species parameter dataframe that
specifies the weight at which 25\% of individuals are mature, which sets
\eqn{U = \log(3) / \log(w_{mat} / w_{25}).}{U = log(3) / log(w_mat / w_25).}

The sigmoidal function given above would strictly reach 1 only asymptotically.
Mizer instead sets the function equal to 1 already at the species' 
maximum size, taken from the compulsory \code{w_inf} column in the
\code{species_params} data frame.

If the \code{repro_prop} argument is not supplied, it is set to the
allometric form
\deqn{{\tt repro\_prop}(w) = \left(\frac{w}{w_{inf}}\right)^{m-n}.}{
  repro_prop = (w/w_inf)^(m - n).}
Here \eqn{n} is the scaling exponent of the energy income rate. Hence
the exponent \eqn{m} determines the scaling of the investment into
reproduction for mature individuals. By default it is chosen to be 
\eqn{m = 1} so that the rate at which energy is invested into reproduction 
scales linearly with the size. This default can be overridden by including a 
column \code{m} in the species parameter dataframe. The asymptotic sizes
are taken from the compulsory \code{w_inf} column in the species_params
data frame.

The reproductive efficiency, i.e., the proportion of energy allocated to
reproduction that results in offspring biomass, is set from the 
\code{erepro} column in the species_params data frame. If that is not
provided the default is set to 1 (which you will want to override).
The offspring biomass divided by the egg biomass gives the
density-independent rate of egg production, returned by \code{\link{getRDI}}.

Mizer allows some density dependence in the production of eggs by putting
the density-independent rate of egg production through a stock-recruitment
function. The result is returned by \code{\link{getRDD}}. The
stock-recruitment function is specified by the \code{srr} argument. The default
is the Beverton-Holt function \code{\link{srrBevertonHolt}}, which requires
an \code{r_max} column in the species_params data frame giving the maximum
egg production rate. If this column does not exist, it is initialised to 
\code{Inf}, leading to no density-dependence.
}

\section{Setting fishing}{

In \code{mizer}, fishing mortality is imposed on species by fishing gears. The
total fishing mortality is obtained by summing over the mortality from all
gears,
\deqn{\mu_{f.i}(w) = \sum_g F_{g,i}(w),}
where the fishing mortality \eqn{F_{g,i}(w)} imposed by gear \eqn{g} on
species \eqn{i} at size \eqn{w} is calculated as:
\deqn{F_{g,i}(w) = S_{g,i}(w) Q_{g,i} E_{g},}
where \eqn{S} is the selectivity by species, gear and size, \eqn{Q} is the
catchability by species and gear and \eqn{E} is the fishing effort by gear.
At the moment a species can only be selected by one fishing gear, although
each gear can select more than one species (this is a limitation with the
current package that will be developed in future releases).

\strong{Selectivity}

The selectivity at size of each gear has a range between 0 (not selected at
that size) to 1 (fully selected at that size). It is given by a selectivity
function. The name of the selectivity function is given by the \code{sel_func}
column in the species parameters data frame. Some selectivity functions are
included in the package: \code{knife_edge()} and \code{sigmoid_length()}. New functions
can be defined by the user. Each gear has the same selectivity function for
all the species it selects, but the parameter values for each species may be
different, e.g. the lengths of species that a gear selects may be different.

Each selectivity function has a range of arguments. Values for these
arguments must be included as columns in the species parameters data.frame.
The names of the columns must exactly match the names of the arguments. For
example, the default selectivity function is \code{knife_edge()} which has sudden
change of selectivity from 0 to 1 at a certain size.
In its help page you can see that the \code{knife_edge()} function has arguments \code{w} and
\code{knife_edge_size} The first argument, \code{w}, is size (the function calculates
selectivity at size). All selectivity functions must have \code{w} as the first
argument. The values for the other arguments must be found in the species
parameters data.frame. So for the \code{knife_edge()} function there should be a
\code{knife_edge_size} column. Because \code{knife_edge()} is the default
selectivity function, the \code{knife_edge_size} argument has a default
value = \code{w_mat}.

\strong{Catchability}

Catchability is used as an additional scalar to make the link between gear
selectivity, fishing effort and fishing mortality. For example, it can be set
so that an effort of 1 gives a desired fishing mortality.
In this way effort can then be specified relative to a 'base effort', e.g.
the effort in a particular year.

Because currently mizer only allows one gear to select each species, the
catchability matrix \eqn{Q_{g,i}} reduces to a catchability vector
\eqn{Q_{i}}, and this is given as a column \code{catchability} in the species
parameter data frame. If it is not specified, it defaults to 1.

Fishing effort is not stored in the \code{MizerParams} object.
Instead, effort is set when the simulation is run and can vary through time
with \code{project()}.
}

\section{Setting plankton dynamics}{

Still need to document
}

\section{Setting resource dynamics}{

Besides the size-structured planktonic resource, mizer can also model any number
of unstructured resource components. Such unstructured components are
appropriate whenever the predation on these components is not size based.
Examples include detritus as a resource for detritivores, carrion as a
resource for scavengers, or macroflora on which fish can graze.

During a simulation using \code{\link[=project]{project()}}, the biomasses of the resources are
updated at each time step by calling the functions specified in the
\code{resource_dynamics} list, which has one named entry for each unstructured
resource component. By default a model is set up without unstructured
resource components, so you do not need to provide this list. But if you
do want to use it, you can see an example of how to set up a
\code{resource_dynamics} list in the Examples section of
\code{setResourceDynamics()}.

Mizer provides two functions that you can use to model resource dynamics:
\code{\link[=detritus_dynamics]{detritus_dynamics()}} and \code{\link[=carrion_dynamics]{carrion_dynamics()}}, but you can easily implement
others by following those templates.
As you can see in the documentation of these functions, their arguments are:
the \code{MizerParams} object \code{params}, the current fish size spectra \code{n}, the
current plankton spectrum \code{n_pp}, the current resource biomasses \code{B} and the
current rates calculated by the \code{\link[=getRates]{getRates()}} function.

The other arguments to the resource dynamics functions are model parameters,
like for example growth rates. These need to be provided in the
\code{resource_params} argument which is a named list. One model parameter that
should always be present in this list is the rate of change due to external
causes. This should be given a name of the form \code{resource_external} where
\code{resource} should be replaced by the name of the resource, see for example
\code{detritus_external} in \code{\link[=detritus_dynamics]{detritus_dynamics()}}.

When writing your own resource dynamics functions, you can choose any names
for your other model parameters, but you must make sure not to use the same
name in the function for another resource component. One way to ensure this
is to prefix all parameter names with your resource name.

The dynamics for a resource should always have a loss term accounting for
the consumption of the resource. This should always have the form used in the
example function \code{\link[=detritus_dynamics]{detritus_dynamics()}}, in order to be in agreement with the
feeding by consumers that is set with \code{\link{setResourceEncounter}}.
}

\section{Setting resource encounter rate}{

The resource encounter rate \eqn{\rho_{id}(w)} (units 1/year) determines the
rate at which an individual of species \eqn{i} encounters biomass of resource
\eqn{d}, so that the contribution from all unstructured resources to the
total encounter rate is
\deqn{E_{u.i}(w) = \sum_d\rho_{id}(w) B_d,} 
where \eqn{B_d} is the biomass of the d-th unstructured resource component.

Resource consumption is subject to satiation in the same way as other food,
so that a consumer only consumes a fraction \eqn{1-f_i(w)} of the encountered
resource biomass, where \eqn{f_i(w)} is the feeding level.

If the \code{rho} array is not supplied, then the resource encounter rate is
set to a power law
\deqn{\rho_{id}(w) = \rho_{id} w^n.}
The coefficients \eqn{\rho_{id}} are parameters in the species_params dataframe.
For example if there is a resource called "detritus" then the species_params
data frame needs to have a column called \code{rho_detritus} and similarly
for each other resource.

If the \code{rho} array is supplied, the ordering of the entries in the array
is important. The order of the species in the first array dimension needs to
be the same as that in the species parameter dataframe. The order of the
resources in the second array dimension must be the same as in the list of
resource dynamics. The third dimension is the size dimension.
}

\examples{
\dontrun{
params <- set_trait_model()
params@species_params$gamma[3] <- 1000
params <- setParams(params)
}
}
\seealso{
Other functions for setting parameters: \code{\link{setBMort}},
  \code{\link{setFishing}}, \code{\link{setInitial}},
  \code{\link{setIntakeMax}}, \code{\link{setInteraction}},
  \code{\link{setMetab}}, \code{\link{setPlankton}},
  \code{\link{setPredKernel}},
  \code{\link{setReproduction}},
  \code{\link{setResourceDynamics}},
  \code{\link{setResourceEncounter}},
  \code{\link{setSearchVolume}}
}
\concept{functions for setting parameters}
